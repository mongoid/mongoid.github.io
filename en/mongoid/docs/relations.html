<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta content='A Ruby ODM for MongoDB' name='description' />
    <meta content='mongoid, mongodb, ruby, rails, odm, durran jordan' name='keywords' />
    <link href="/stylesheets/bootstrap.min.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/mongoid.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/mongoid-coderay.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/bootstrap-responsive.min.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/jquery-1.7.2.js" type="text/javascript"></script>
    <script src="/javascripts/bootstrap-dropdown.js" type="text/javascript"></script>
    <script src="/javascripts/bootstrap-scrollspy.js" type="text/javascript"></script>
    <script src="/javascripts/bootstrap-tooltip.js" type="text/javascript"></script>
    <script src="/javascripts/mongoid.js" type="text/javascript"></script>
    <title>Mongoid: Relations</title>
  </head>
  <body data-offset='100' data-spy='scroll' data-target='.page-nav'>
    <div class='basic' id='header'>
      <div class='navbar navbar-fixed-top'>
        <div class='navbar-inner'>
          <div class='container'>
            <ul class='nav'>
              <li class='dropdown link' id='project'>
                            <a title="Mongoid" href="/en/mongoid/"><img src="/images/mongoid-logo-small-green.png" />
                </a>
    
              </li>
              <li class='link'>
                            <a title="Origin" href="/en/origin/"><img src="/images/origin-logo-small-white.png" />
                </a>
    
              </li>
              <li class='link'>
                            <a title="Moped" href="/en/moped/"><img src="/images/moped-logo-small-white.png" />
                </a>
    
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div id='navigation'>
      <div class='subnav'>
        <div class='container'>
          <ul class='nav nav-pills'>
            <li><a href="/en/mongoid/">HOME</a></li>
            <li class='dropdown' id='docs'>
              <a class='dropdown-toggle' data-toggle='dropdown' href='#docs'>
                DOCS
                <b class='caret'></b>
              </a>
              <ul class='dropdown-menu'>
                <li><a href="/en/mongoid/docs/installation.html">Installation</a></li>
                <li><a href="/en/mongoid/docs/documents.html">Documents</a></li>
                <li><a href="/en/mongoid/docs/persistence.html">Persistence</a></li>
                <li><a href="/en/mongoid/docs/querying.html">Querying</a></li>
                <li><a href="/en/mongoid/docs/relations.html">Relations</a></li>
                <li><a href="/en/mongoid/docs/nested_attributes.html">Nested Attributes</a></li>
                <li><a href="/en/mongoid/docs/identity_map.html">Identity Map</a></li>
                <li><a href="/en/mongoid/docs/callbacks.html">Callbacks</a></li>
                <li><a href="/en/mongoid/docs/validation.html">Validation</a></li>
                <li><a href="/en/mongoid/docs/indexing.html">Indexing</a></li>
                <li><a href="/en/mongoid/docs/rails.html">Rails</a></li>
                <li><a href="/en/mongoid/docs/extras.html">Extras</a></li>
                <li><a href="/en/mongoid/docs/upgrading.html">Upgrading</a></li>
                <li><a href="/en/mongoid/docs/contributing.html">Contributing</a></li>
                <li><a href="/en/mongoid/docs/performance.html">Performance</a></li>
                <li><a href="/en/mongoid/docs/tips.html">Tips/FAQs</a></li>
              </ul>
            </li>
            <li><a href="/en/mongoid/links.html">LINKS</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div id='content'>
      <div class='container'>
        <h1>Relations</h1>
        <p>
          Relations are associations between one model and another in the domain
          and in the database. Embedded relations describe documents who are
          stored inside other documents in the database. Referenced relations
          describe documents that reference documents in another collection by
          storing foreign key data (usually an id) about the other document
          in itself.
        </p>
        <p>
          All relation objects in Mongoid are proxies to the actual document or
          documents themselves, which provide extra functionality for accessing,
          replacing, appending and persisting.
        </p>
        <div class='page-nav'>
          <div class='container'>
            <ul class='nav nav-pills'>
              <li><a href="#common">Common Behaviour</a></li>
              <li><a href="#metadata">Metadata</a></li>
              <li><a href="#embeds_one">Embedded 1-1</a></li>
              <li><a href="#embeds_many">Embedded 1-n</a></li>
              <li><a href="#has_one">Referenced 1-1</a></li>
              <li><a href="#has_many">Referenced 1-n</a></li>
              <li><a href="#has_and_belongs_to_many">Referenced n-n</a></li>
            </ul>
          </div>
        </div>
        <section id='common'>
          <h2>Common Behaviour</h2>
          <h3>Attributes</h3>
          <p>
            All relations contain a <code>target</code>, which is the proxied document
            or documents, a <code>base</code> which is the document the relation hangs
            off, and <code>metadata</code> which provides information about the relation.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Person</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:addresses</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;person.addresses = [ address ]&#x000A;person.addresses.target <span class="comment"># returns [ address ]</span>&#x000A;person.addresses.base <span class="comment"># returns person</span>&#x000A;person.addresses.metadata <span class="comment"># returns the metadata</span>&#x000A;</pre></div>
          </div>
          <h3>Extensions</h3>
          <p>
            All relations can have extensions, which provides a way to add
            application specific functionality to the relation. They are defined by
            providing a block to the relation definition.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Person</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:addresses</span> <span class="keyword">do</span>&#x000A;    <span class="keyword">def</span> <span class="function">find_by_country</span>(country)&#x000A;      where(country: country).first&#x000A;    <span class="keyword">end</span>&#x000A;    <span class="keyword">def</span> <span class="function">chinese</span>&#x000A;      <span class="instance-variable">@target</span>.select { |address| address.country == <span class="string"><span class="delimiter">&quot;</span><span class="content">China</span><span class="delimiter">&quot;</span></span>}&#x000A;    <span class="keyword">end</span>&#x000A;  <span class="keyword">end</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;person.addresses.find_by_country(<span class="string"><span class="delimiter">&quot;</span><span class="content">Mongolia</span><span class="delimiter">&quot;</span></span>) <span class="comment"># returns address</span>&#x000A;person.addresses.chinese <span class="comment"># returns [ address ]</span>&#x000A;</pre></div>
          </div>
          <h3>Custom Relation Names</h3>
          <p>
            You can name your relations whatever you like, but if the class cannot be
            inferred by Mongoid from the name, and neither can the opposite side you'll
            want to provide the macro with some additional options to tell Mongoid
            how to hook them up.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Lush</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:whiskey</span>, class_name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Drink</span><span class="delimiter">&quot;</span></span>, inverse_of: <span class="symbol">:alcoholic</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Drink</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embedded_in <span class="symbol">:alcoholic</span>, class_name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Lush</span><span class="delimiter">&quot;</span></span>, inverse_of: <span class="symbol">:whiskey</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <h3>Validations</h3>
          <p>
            It is important to note that by default, Mongoid will validate the
            children of any relation that are loaded into memory via a
            <code>validates_associated</code>. The relations that this applies to are:
            <ul>
              <li><code>embeds_many</code></li>
              <li><code>embeds_one</code></li>
              <li><code>has_many</code></li>
              <li><code>has_one</code></li>
              <li><code>has_and_belongs_to_many</code></li>
            </ul>
          </p>
          <p>
            If you do not want this behavior, you may turn it off when defining
            the relation.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Person</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;&#x000A;  embeds_many <span class="symbol">:addresses</span>, validate: <span class="predefined-constant">false</span>&#x000A;  has_many <span class="symbol">:posts</span>, validate: <span class="predefined-constant">false</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <h3>Polymorphism</h3>
          <p>
            When a child embedded document can belong to more than one type of parent
            document, you can tell Mongoid to support this by adding the <code>as</code>
            option to the definition on the parents, and the <code>polymorphic</code>
            option on the child. On the child object, and additional field will be
            stored that indicates the type of the parent.
          </p>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>
                    Polymorhic behavior is allowed on all relations with the
                    exception of <code>has_and_belongs_to_many</code>.
                  </p>
                </td>
              </tr>
            </table>
          </div>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:photos</span>, as: <span class="symbol">:photographic</span>&#x000A;  has_one <span class="symbol">:address</span>, as: <span class="symbol">:addressable</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Photo</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embedded_in <span class="symbol">:photographic</span>, polymorphic: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Address</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  belongs_to <span class="symbol">:addressable</span>, polymorphic: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <h3>Cascading Callbacks</h3>
          <p>
            If you want the embedded document callbacks to fire when calling a persistence
            operation on it's parent, you will need to provide the cascade callbacks
            option to the relation.
          </p>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>
                    Cascading callbacks is only available on <code>embeds_one</code>
                    and <code>embeds_many</code> relations.
                  </p>
                </td>
              </tr>
            </table>
          </div>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:albums</span>, cascade_callbacks: <span class="predefined-constant">true</span>&#x000A;  embeds_one <span class="symbol">:label</span>, cascade_callbacks: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band.save <span class="comment"># Fires all save callbacks on the band, albums, and label.</span>&#x000A;</pre></div>
          </div>
          <h3>Dependent Behaviour</h3>
          <p>
            You can provided dependent options to referenced associations to
            instruct Mongoid how to handle situations where one side of the
            relation is deleted, or is attempted to be deleted. The options
            are as follows:
          </p>
          <ul>
            <li><code>:delete</code>: Delete the child document.</li>
            <li><code>:destroy</code>: Destroy the child document.</li>
            <li><code>:nullify</code>: Orphan the child document.</li>
            <li><code>:restrict</code>: Raise an error if the child is not empty.</li>
          </ul>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>Dependent options are only available on referenced relations.</p>
                </td>
              </tr>
            </table>
          </div>
          <p>
            The default behavior of each association when no dependent option
            is provided is to nullify.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:albums</span>, dependent: <span class="symbol">:delete</span>&#x000A;  belongs_to <span class="symbol">:label</span>, dependent: <span class="symbol">:nullify</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Album</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  belongs_to <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Label</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:bands</span>, dependent: <span class="symbol">:restrict</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;label = <span class="constant">Label</span>.first&#x000A;label.bands.push(<span class="constant">Band</span>.first)&#x000A;label.delete <span class="comment"># Raises an error since bands is not empty.</span>&#x000A;&#x000A;<span class="constant">Band</span>.first.delete <span class="comment"># Will delete all associated albums.</span>&#x000A;</pre></div>
          </div>
          <h3>Autosaving</h3>
          <p>
            One core difference between Mongoid and Active Record from a behavior
            standpoint is that Mongoid does not automatically save child relations
            for relational associations. This is for performance reasons.
          </p>
          <p>
            To enable an autosave on a relational association (embedded associations
            do not need this since they are actually part of the parent in the
            database) add the <code>autosave</code> option to the relation.
          </p>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  Note that autosave functionality will automatically be added to a
                  relation when using <code>accepts_nested_attributes_for</code> or
                  validating presence of the relation.
                </td>
              </tr>
            </table>
          </div>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:albums</span>, autosave: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band = <span class="constant">Band</span>.first&#x000A;band.albums.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">101</span><span class="delimiter">&quot;</span></span>)&#x000A;band.save <span class="comment">#=&gt; Will save the album as well.</span>&#x000A;</pre></div>
          </div>
          <h3>Recursive Embedding</h3>
          <p>
            A document can recursively embed itself using
            <code>recursively_embeds_one</code> or <code>recursively_embeds_many</code>,
            which provides accessors for the parent and children via <code>parent_</code>
            and <code>child_</code> methods.
          </p>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>Recursive options are only available on embedded relations.</p>
                </td>
              </tr>
            </table>
          </div>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Tag</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  recursively_embeds_many&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;root = <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">programming</span><span class="delimiter">&quot;</span></span>)&#x000A;child_one = root.child_tags.build&#x000A;child_one = root.child_tags.build&#x000A;&#x000A;root.child_tags <span class="comment"># [ child_one, child_two ]</span>&#x000A;child_one.parent_tag <span class="comment"># [ root ]</span>&#x000A;child_two.parent_tag <span class="comment"># [ root ]</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Node</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  recursively_embeds_one&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;root = <span class="constant">Node</span>.new&#x000A;child = <span class="constant">Node</span>.new&#x000A;root.child_node = child&#x000A;&#x000A;root.child <span class="comment"># child</span>&#x000A;child.parent_node <span class="comment"># root</span>&#x000A;</pre></div>
          </div>
          <h3>Existence Predicates</h3>
          <p>
            All relations have existence predicates on them in the form of
            <code>name?</code> and <code>has_name?</code> to check if the relation
            is blank.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>&#x000A;  embeds_many <span class="symbol">:albums</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band.label?&#x000A;band.has_label?&#x000A;band.albums?&#x000A;band.has_albums?&#x000A;</pre></div>
          </div>
          <h3>Autobuilding</h3>
          <p>
            One to one relations (<code>embeds_one</code>, <code>has_one</code>) have
            an <code>autobuild</code> option which tells Mongoid to instantiate a
            new document when the relation is accessed and it is <code>nil</code>
          </p>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>
                    Existence predicates will not trigger an autobuild, so they will
                    properly return <code>false</code> if the document is not
                    present.
                  </p>
                </td>
              </tr>
            </table>
          </div>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>, autobuild: <span class="predefined-constant">true</span>&#x000A;  has_one <span class="symbol">:producer</span>, autobuild: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band = <span class="constant">Band</span>.new&#x000A;band.label <span class="comment"># Returns a new empty label.</span>&#x000A;band.producer <span class="comment"># Returns a new empty producer.</span>&#x000A;</pre></div>
          </div>
          <h3>Touching</h3>
          <p>
            Any <code>belongs_to</code> relation, no matter where it hangs off from,
            can take an optional <code>:touch</code> option which will call the
            touch method on it and any parent relations with the option defined when
            the base document calls <code>#touch</code>.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  belongs_to <span class="symbol">:label</span>, touch: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band = <span class="constant">Band</span>.first&#x000A;band.touch <span class="comment">#=&gt; Calls touch on the parent label.</span>&#x000A;</pre></div>
          </div>
        </section>
        <section id='metadata'>
          <h2>Metadata</h2>
          <p>
            All relations in Mongoid contain metadata that holds information
            about the relation in question, and is a valuable tool for third
            party developers to use to extend Mongoid.
          </p>
          <p>
            You can access the metadata of the relation in a few different ways.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="comment"># Get the metadata for a named relation from the class or document.</span>&#x000A;<span class="constant">Model</span>.reflect_on_association(<span class="symbol">:relation_name</span>)&#x000A;model.reflect_on_association(<span class="symbol">:relation_name</span>)&#x000A;&#x000A;<span class="comment"># Get the metadata that the current object has in its relation.</span>&#x000A;model.metadata&#x000A;&#x000A;<span class="comment"># Get the metadata with a specific relation itself on a specific</span>&#x000A;<span class="comment"># document.</span>&#x000A;person.addresses.metadata&#x000A;</pre></div>
          </div>
          <h3>The Metadata Object</h3>
          <p>
            The metadata object itself contains more information than one might
            know what to do with, and is useful for developers of extensions
            to Mongoid.
          </p>
          <table class='table table-bordered table-striped'>
            <thead>
              <tr>
                <th>Method</th>
                <th>Description</th>
              </tr>
            </thead>
            <tr>
              <td><code>Metadata#as</code></td>
              <td>Returns the name of the parent to a polymorphic child.</td>
            </tr>
            <tr>
              <td><code>Metadata#as?</code></td>
              <td>Returns whether or not an as option exists.</td>
            </tr>
            <tr>
              <td><code>Metadata#autobuilding?</code></td>
              <td>Returns whether or not the relation is autobuilding.</td>
            </tr>
            <tr>
              <td><code>Metadata#autosaving?</code></td>
              <td>Returns whether or not the relation is autosaving.</td>
            </tr>
            <tr>
              <td><code>Metadata#cascading_callbacks?</code></td>
              <td>
                Returns whether the relation has callbacks cascaded down from
                the parent.
              </td>
            </tr>
            <tr>
              <td><code>Metadata#class_name</code></td>
              <td>Returns the class name of the proxied document.</td>
            </tr>
            <tr>
              <td><code>Metadata#cyclic?</code></td>
              <td>Returns whether the relation is a cyclic relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#dependent</code></td>
              <td>Returns the relation's dependent option.</td>
            </tr>
            <tr>
              <td><code>Metadata#dependent?</code></td>
              <td>Returns whether the relation is a dependent relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#destructive?</code></td>
              <td>Returns true if the relation has a dependent delete or destroy.</td>
            </tr>
            <tr>
              <td><code>Metadata#embedded?</code></td>
              <td>Returns whether the relation is embedded in another document.</td>
            </tr>
            <tr>
              <td><code>Metadata#forced_nil_inverse?</code></td>
              <td>Returns whether the relation has a nil inverse defined.</td>
            </tr>
            <tr>
              <td><code>Metadata#foreign_key</code></td>
              <td>Returns the name of the foreign key field.</td>
            </tr>
            <tr>
              <td><code>Metadata#foreign_key_check</code></td>
              <td>Returns the name of the foreign key field dirty check method.</td>
            </tr>
            <tr>
              <td><code>Metadata#foreign_key_setter</code></td>
              <td>Returns the name of the foreign key field setter.</td>
            </tr>
            <tr>
              <td><code>Metadata#indexed?</code></td>
              <td>Returns whether the foreign key is auto indexed.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverses</code></td>
              <td>Returns the names of all inverse relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse</code></td>
              <td>Returns the name of a single inverse relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_class_name</code></td>
              <td>Returns the class name of the relation on the inverse side.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_foreign_key</code></td>
              <td>Returns the name of the foreign key field on the inverse side.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_klass</code></td>
              <td>Returns the class of the relation on the inverse side.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_metadata</code></td>
              <td>Returns the metadata of the relation on the inverse side.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_of</code></td>
              <td>Returns the explicitly defined name of the inverse relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_of?</code></td>
              <td>Returns whether an <code>inverse_of</code> option is defined.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_setter</code></td>
              <td>Returns the name of the method used to set the inverse.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_type</code></td>
              <td>Returns the name for the polymorphic type field of the inverse.</td>
            </tr>
            <tr>
              <td><code>Metadata#inverse_type_setter</code></td>
              <td>Returns the name for the polymorphic type field setter of the inverse.</td>
            </tr>
            <tr>
              <td><code>Metadata#key</code></td>
              <td>
                Returns the name of the field in the attributes hash to use to get
                the relation.
              </td>
            </tr>
            <tr>
              <td><code>Metadata#klass</code></td>
              <td>Returns the class of the proxied documents in the relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#macro</code></td>
              <td>Returns the relation's macro.</td>
            </tr>
            <tr>
              <td><code>Metadata#name</code></td>
              <td>Returns the relation name.</td>
            </tr>
            <tr>
              <td><code>Metadata#options</code></td>
              <td>Returns self, for API compatibility with Active Record.</td>
            </tr>
            <tr>
              <td><code>Metadata#order</code></td>
              <td>Returns the custom sorting options on the relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#order?</code></td>
              <td>Returns whether custom sorting options are set.</td>
            </tr>
            <tr>
              <td><code>Metadata#polymorphic?</code></td>
              <td>Returns whether the relation is polymorphic.</td>
            </tr>
            <tr>
              <td><code>Metadata#setter</code></td>
              <td>Returns the name of the field to set the relation.</td>
            </tr>
            <tr>
              <td><code>Metadata#store_as</code></td>
              <td>Returns the name of the attribute to store an embedded relation in.</td>
            </tr>
            <tr>
              <td><code>Metadata#touchable?</code></td>
              <td>Returns whether or not the relation has a touch option.</td>
            </tr>
            <tr>
              <td><code>Metadata#type</code></td>
              <td>Returns the name of the field to get the polymorphic type.</td>
            </tr>
            <tr>
              <td><code>Metadata#type_setter</code></td>
              <td>Returns the name of the field to set the polymorphic type.</td>
            </tr>
            <tr>
              <td><code>Metadata#validate?</code></td>
              <td>Returns whether the relation has an associated validation.</td>
            </tr>
            <tr>
              <td><code>Metadata#versioned?</code></td>
              <td>Returns whether the relation is an embedded version.</td>
            </tr>
          </table>
        </section>
        <section id='embeds_one'>
          <h2>Embedded 1-1</h2>
          <p>
            One to one relationships where the children are embedded in the parent
            document are defined using Mongoid's <code>embeds_one</code> and
            <code>embedded_in</code> macros.
          </p>
          <h3>Defining</h3>
          <p>
            The parent document of the relation should use the <code>embeds_one</code>
            macro to indicate is has 1 embedded child, where the document that
            is embedded uses <code>embedded_in</code>.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Label</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  embedded_in <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>
                    Definitions are required on both sides to the relation in order
                    for it to work properly.
                  </p>
                </td>
              </tr>
            </table>
          </div>
          <h3>Storage</h3>
          <p>
            Documents that are embedded using the <code>embeds_one</code> macro are stored
            as a hash inside the parent in the parent's database collection.
          </p>
          <div class="CodeRay">
            <div class="code"><pre>{&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">label</span><span class="delimiter">&quot;</span></span> : {&#x000A;    <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e0</span><span class="delimiter">&quot;</span></span>),&#x000A;    <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>,&#x000A;  }&#x000A;}&#x000A;</pre></div>
          </div>
          <p>
            You can optionally tell Mongoid to store the embedded document in a
            different attribute other than the name, by providing a <code>:store_as</code>
            option.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>, store_as: <span class="string"><span class="delimiter">&quot;</span><span class="content">lab</span><span class="delimiter">&quot;</span></span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <h3>Operations</h3>
          <p>
            Once the relation is defined, the following operations are available, and
            the following table shows any database operations that are performed if
            applicable. The previously defined models will be used for example code.
          </p>
          <table class='table table-bordered table-striped'>
            <thead>
              <tr>
                <th>Operation</th>
                <th>Mongoid</th>
                <th>Moped</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class='doc'>
                  <code>Model#{name}</code>
                  <p class='doc'>
                    <i>Get the embedded document.</i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.label</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}=</code>
                  <p class='doc'>
                    <i>
                      Set the embedded document. If the parent document is persisted,
                      then the child will be atomically saved immediately. If setting
                      to <code>nil</code> then the child will be deleted.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.label = <span class="constant">Label</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;band.label = <span class="predefined-constant">nil</span></pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$set</span><span class="delimiter">&quot;</span></span> =&gt; { label: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$unset</span><span class="delimiter">&quot;</span></span> =&gt; { label: <span class="predefined-constant">true</span> })&#x000A;</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}</code>
                  <p class='doc'>
                    <i>
                      Get the parent document from the child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>label.band</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}=</code>
                  <p class='doc'>
                    <i>
                      Set the parent document from the child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>label.band = <span class="constant">Band</span>.new</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#build_{name}</code>
                  <p class='doc'>
                    <i>
                      Build a new document on the relation.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.build_label(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;label.build_band(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#create_{name}</code>
                  <p class='doc'>
                    <i>
                      Create a new document from either side of the relation.
                      This persists the child immediately if executing from the parent,
                      and persists the entire tree if executed from the child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.create_label(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;label.create_band({&#x000A;  name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$set</span><span class="delimiter">&quot;</span></span> =&gt; { label: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].&#x000A;  insert({&#x000A;    name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>,&#x000A;    label: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span> }&#x000A;  })&#x000A;</pre></div>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id='embeds_many'>
          <h2>Embedded 1-n</h2>
          <p>
            One to many relationships where the children are embedded in the parent
            document are defined using Mongoid's <code>embeds_many</code> and
            <code>embedded_in</code> macros.
          </p>
          <h3>Defining</h3>
          <p>
            The parent document of the relation should use the <code>embeds_many</code>
            macro to indicate it has <i>n</i> number of embedded children, where
            the document that is embedded uses <code>embedded_in</code>.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:albums</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Album</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  embedded_in <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>
                    Definitions are required on both sides to the relation in order
                    for it to work properly.
                  </p>
                </td>
              </tr>
            </table>
          </div>
          <h3>Storage</h3>
          <p>
            Documents that are embedded using the <code>embeds_many</code> macro are stored
            as an array of hashes inside the parent in the parent's database
            collection.
          </p>
          <div class="CodeRay">
            <div class="code"><pre>{&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">albums</span><span class="delimiter">&quot;</span></span> : [&#x000A;    {&#x000A;      <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e0</span><span class="delimiter">&quot;</span></span>),&#x000A;      <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>,&#x000A;    }&#x000A;  ]&#x000A;}&#x000A;</pre></div>
          </div>
          <p>
            You can optionally tell Mongoid to store the embedded document in a
            different attribute other than the name, by providing a <code>:store_as</code>
            option.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:albums</span>, store_as: <span class="string"><span class="delimiter">&quot;</span><span class="content">albs</span><span class="delimiter">&quot;</span></span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <h3>Operations</h3>
          <p>
            Once the relation is defined, the following operations are available, and
            the following table shows any database operations that are performed if
            applicable. The previously defined models will be used for example code.
          </p>
          <table class='table table-bordered table-striped'>
            <thead>
              <tr>
                <th>Operation</th>
                <th>Mongoid</th>
                <th>Moped</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class='doc'>
                  <code>Model#{name}</code>
                  <p class='doc'>
                    <i>Get the embedded documents.</i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}=</code>
                  <p class='doc'>
                    <i>
                      Set the embedded documents. If the parent document is persisted,
                      then the child will be atomically saved immediately. If setting
                      to <code>nil</code> or <code>[]</code> then the children will be
                      deleted.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums = [ <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>) ]&#x000A;&#x000A;band.albums = <span class="predefined-constant">nil</span>&#x000A;band.albums = []</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$set</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$unset</span><span class="delimiter">&quot;</span></span> =&gt; { albums: <span class="predefined-constant">true</span> })&#x000A;</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}</code>
                  <p class='doc'>
                    <i>
                      Get the parent document from any child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>album.band</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}=</code>
                  <p class='doc'>
                    <i>
                      Set the parent document from a child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>album.band = <span class="constant">Band</span>.new</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.<<</code><br/>
                  <code>Model#{name}.push</code>
                  <p class='doc'>
                    <i>
                      Push a new document onto the relation. If the parent is
                      persisted, then the child documents will be automatically
                      saved.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums &lt;&lt; <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.push(<span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>))</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.concat</code>
                  <p class='doc'>
                    <i>
                      Push multiple documents onto the relation. If the parent is
                      persisted, then the child documents will be automatically
                      saved. <b>This is a batch operation that runs validations, but
                      no other callbacks.</b>
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.concat(&#x000A;  <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">101</span><span class="delimiter">&quot;</span></span>)&#x000A;)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pushAll</span><span class="delimiter">&quot;</span></span> =&gt; {&#x000A;      albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }, { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">101</span><span class="delimiter">&quot;</span></span> }]&#x000A;    }&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.build</code><br/>
                  <code>Model#{name}.new</code>
                  <p class='doc'>
                    <i>
                      Build a new document in the relation with the provided
                      attributes. Does not save the new document.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.create</code><br/>
                  <code>Model#{name}.create!</code>
                  <p class='doc'>
                    <i>
                      Create a new document in the relation with the provided
                      attributes and saves. With the bang version an error will
                      be raised if validation fails.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.create(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.create!(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.clear</code><br/>
                  <code>Model#{name}.delete_all</code>
                  <p class='doc'>
                    <i>
                      Deletes all documents from the relation, without
                      running any callbacks.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.clear&#x000A;band.albums.delete_all&#x000A;band.albums.delete_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>).delete_all</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.destroy_all</code>
                  <p class='doc'>
                    <i>
                      Deletes all documents from the relation, while
                      running the destroy callbacks.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.destroy_all&#x000A;band.albums.destroy_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>).destroy_all</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.delete</code>
                  <p class='doc'>
                    <i>
                      Deletes the matching document from the relation.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.delete(album)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pull</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.pop</code>
                  <p class='doc'>
                    <i>
                      Deletes the provided number of documents, defaulting to 1.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.pop&#x000A;band.albums.pop(<span class="integer">1</span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find</code>
                  <p class='doc'>
                    <i>
                      Return documents in the relation with matching ids. Will
                      raise an error if all the ids are not found by default.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.find(id)&#x000A;band.albums.find(id_one, id_two)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find_or_create_by</code>
                  <p class='doc'>
                    <i>
                      Search for the document in the relation, and if not found
                      create a newly persisted one.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.&#x000A;  find_or_create_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find_or_initialize_by</code>
                  <p class='doc'>
                    <i>
                      Search for the document in the relation, and if not found
                      add a new one.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.&#x000A;  find_or_initialize_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.where</code>
                  <p class='doc'>
                    <i>
                      Find matching documents in the relation. This can be any
                      criteria method, not just where.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.exists?</code>
                  <p class='doc'>
                    <i>
                      Returns whether or not the relation has any documents.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.albums.exists?</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id='has_one'>
          <h2>Referenced 1-1</h2>
          <p>
            One to one relationships where the children are referenced in the parent
            document are defined using Mongoid's <code>has_one</code> and
            <code>belongs_to</code> macros.
          </p>
          <h3>Defining</h3>
          <p>
            The parent document of the relation should use the <code>has_one</code>
            macro to indicate is has 1 referenced child, where the document that
            is referenced in it uses <code>belongs_to</code>.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_one <span class="symbol">:studio</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Studio</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  belongs_to <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <p>
            Definitions are required on both sides to the relation in order for it to
            work properly.
          </p>
          <h3>Storage</h3>
          <p>
            When defining a relation of this nature, each document is stored in it's
            respective collection, but the child document contains a "foreign key"
            reference to the parent.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="comment"># The parent band document.</span>&#x000A;{ <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>) }&#x000A;&#x000A;<span class="comment"># The child studio document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f1</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">band_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>)&#x000A;}&#x000A;</pre></div>
          </div>
          <h3>Operations</h3>
          <p>
            Once the relation is defined, the following operations are available, and
            the following table shows any database operations that are performed if
            applicable. The previously defined models will be used for example code.
          </p>
          <table class='table table-bordered table-striped'>
            <thead>
              <tr>
                <th>Operation</th>
                <th>Mongoid</th>
                <th>Moped</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class='doc'>
                  <code>Model#{name}</code>
                  <p class='doc'>
                    <i>Get the child document.</i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.studio</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}=</code>
                  <p class='doc'>
                    <i>
                      Set the child document. If the parent document is persisted,
                      then the child will be saved immediately. If setting
                      to <code>nil</code> then the child will be deleted.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.studio = <span class="constant">Studio</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;band.studio = <span class="predefined-constant">nil</span></pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:studios</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)&#x000A;&#x000A;collections[<span class="symbol">:studios</span>].find(...).remove&#x000A;</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}</code>
                  <p class='doc'>
                    <i>
                      Get the parent document from the child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>studio.band</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}=</code>
                  <p class='doc'>
                    <i>
                      Set the parent document from the child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>studio.band = <span class="constant">Band</span>.new</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#build_{name}</code>
                  <p class='doc'>
                    <i>
                      Build a new document on the relation. This does not save the
                      new document.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.build_studio(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;studio.build_band(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#create_{name}</code>
                  <p class='doc'>
                    <i>
                      Create a new document from either side of the relation.
                      This persists the child immediately if executing from the parent,
                      and persists the parent if executed from the child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.create_studio(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;studio.create_band(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:studios</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span> }&#x000A;)&#x000A;</pre></div>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id='has_many'>
          <h2>Referenced 1-n</h2>
          <p>
            One to many relationships where the children are stored in a
            separate collection from the parent document are defined using
            Mongoid's <code>has_many</code> and <code>belongs_to</code> macros. This
            exhibits similar behavior to Active Record.
          </p>
          <h3>Defining</h3>
          <p>
            The parent document of the relation should use the <code>has_many</code>
            macro to indicate is has <i>n</i> number of referenced children, where
            the document that is referenced uses <code>belongs_to</code>.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:members</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Member</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  belongs_to <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <p>
            Definitions are required on both sides to the relation in order for it to
            work properly.
          </p>
          <h3>Storage</h3>
          <p>
            When defining a relation of this nature, each document is stored in it's
            respective collection, but the child document contains a "foreign key"
            reference to the parent.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="comment"># The parent band document.</span>&#x000A;{ <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>) }&#x000A;&#x000A;<span class="comment"># The child member document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f1</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">band_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>)&#x000A;}&#x000A;</pre></div>
          </div>
          <h3>Operations</h3>
          <p>
            Once the relation is defined, the following operations are available, and
            the following table shows any database operations that are performed if
            applicable. The previously defined models will be used for example code.
          </p>
          <table class='table table-bordered table-striped'>
            <thead>
              <tr>
                <th>Operation</th>
                <th>Mongoid</th>
                <th>Moped</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class='doc'>
                  <code>Model#{name}</code>
                  <p class='doc'>
                    <i>Get the related documents.</i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}=</code>
                  <p class='doc'>
                    <i>
                      Set the related documents. If the parent document is persisted,
                      then the child will be saved immediately. If setting
                      to <code>nil</code> or <code>[]</code> then the children will be
                      deleted.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members = [ <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>) ]&#x000A;&#x000A;band.members = <span class="predefined-constant">nil</span>&#x000A;band.members = []</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)&#x000A;&#x000A;collections[<span class="symbol">:members</span>].find(...).remove</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}_ids</code>
                  <p class='doc'>
                    <i>Get the related document ids.</i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.member_ids</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}_ids=</code>
                  <p class='doc'>
                    <i>
                      Set the related document ids.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.member_ids = [ id ]</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}</code>
                  <p class='doc'>
                    <i>
                      Get the parent document from any child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>member.band</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{parent_name}=</code>
                  <p class='doc'>
                    <i>
                      Set the parent document from a child.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>member.band = <span class="constant">Band</span>.new</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.<<</code><br/>
                  <code>Model#{name}.push</code>
                  <p class='doc'>
                    <i>
                      Push a new document onto the relation. If the parent is
                      persisted, then the child documents will be automatically
                      saved.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members &lt;&lt; <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.push(<span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>))</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.concat</code>
                  <p class='doc'>
                    <i>
                      Push multiple documents onto the relation. If the parent is
                      persisted, then the child documents will be automatically
                      saved in a single batch. <b>This is a batch operation that runs
                      validations, but no other callbacks.</b>
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.concat(&#x000A;  <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Martin</span><span class="delimiter">&quot;</span></span>)&#x000A;)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].insert([&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... },&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Martin</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;])</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.build</code><br/>
                  <code>Model#{name}.new</code>
                  <p class='doc'>
                    <i>
                      Build a new document in the relation with the provided
                      attributes. Does not save the new document.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.create</code><br/>
                  <code>Model#{name}.create!</code>
                  <p class='doc'>
                    <i>
                      Create a new document in the relation with the provided
                      attributes and saves. With the bang version an error will
                      be raised if validation fails.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.create(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.create!(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.clear</code><br/>
                  <code>Model#{name}.delete_all</code>
                  <p class='doc'>
                    <i>
                      Deletes all documents from the relation, without
                      running any callbacks.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.clear&#x000A;band.members.delete_all&#x000A;band.members.delete_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).delete_all</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].find(band_id: ...).remove_all&#x000A;&#x000A;collections[<span class="symbol">:members</span>].&#x000A;  find(band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).remove_all</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.destroy_all</code>
                  <p class='doc'>
                    <i>
                      Deletes all documents from the relation, while
                      running the destroy callbacks.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.destroy_all&#x000A;band.members.destroy_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).destroy_all</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].find(band_id: ...).remove_all&#x000A;&#x000A;collections[<span class="symbol">:members</span>].&#x000A;  find(band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).remove_all</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.delete</code>
                  <p class='doc'>
                    <i>
                      Deletes the matching document from the relation.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.delete(member)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].&#x000A;  find(band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).remove</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find</code>
                  <p class='doc'>
                    <i>
                      Return documents in the relation with matching ids. Will
                      raise an error if all the ids are not found by default.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.find(id)&#x000A;&#x000A;band.members.find(id_one, id_two)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., _id: id&#x000A;})&#x000A;&#x000A;collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; [ id_one, id_two ] }&#x000A;})</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find_or_create_by</code>
                  <p class='doc'>
                    <i>
                      Search for the document in the relation, and if not found
                      create a newly persisted one.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.&#x000A;  find_or_create_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>&#x000A;})&#x000A;collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find_or_initialize_by</code>
                  <p class='doc'>
                    <i>
                      Search for the document in the relation, and if not found
                      add a new one.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.&#x000A;  find_or_initialize_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.where</code>
                  <p class='doc'>
                    <i>
                      Find matching documents in the relation. This can be any
                      criteria method, not just where.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.exists?</code>
                  <p class='doc'>
                    <i>
                      Returns whether or not the relation has any documents.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.members.exists?</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:members</span>].find(band_id: ...).count&#x000A;</pre></div>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id='has_and_belongs_to_many'>
          <h2>Referenced n-n</h2>
          <p>
            Many to many relationships where the inverse documents are stored in a
            separate collection from the base document are defined using
            Mongoid's <code>has_and_belongs_to_many</code> macro. This
            exhibits similar behavior to Active Record with the exception that
            no join collection is needed, the foreign key ids are stored as
            arrays on either side of the relation.
          </p>
          <h3>Defining</h3>
          <p>
            Both sides of the relation use the same macro.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_and_belongs_to_many <span class="symbol">:tags</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Tag</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  has_and_belongs_to_many <span class="symbol">:bands</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <p>
            You can create a one sided many to many if you want to mimic a has_many
            that stores the keys as an array on the parent.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_and_belongs_to_many <span class="symbol">:tags</span>, inverse_of: <span class="predefined-constant">nil</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Tag</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
          </div>
          <h3>Storage</h3>
          <p>
            When defining a relation of this nature, each document is stored in it's
            respective collection, and each document contains a "foreign key"
            reference to the other in the form of an array.
          </p>
          <div class="CodeRay">
            <div class="code"><pre><span class="comment"># The band document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">tag_ids</span><span class="delimiter">&quot;</span></span> : [ ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f2</span><span class="delimiter">&quot;</span></span>) ]&#x000A;}&#x000A;&#x000A;<span class="comment"># The tag document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f2</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">band_ids</span><span class="delimiter">&quot;</span></span> : [ ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>) ]&#x000A;}&#x000A;</pre></div>
          </div>
          <h3>Operations</h3>
          <p>
            Once the relation is defined, the following operations are available, and
            the following table shows any database operations that are performed if
            applicable. The previously defined models will be used for example code.
          </p>
          <div class='well'>
            <table>
              <tr>
                <td class='samurai'><img src="/images/samurai.png" /></td>
                <td class='note'>
                  <p>
                    Many to many relations require usually double the amount of
                    hits to the database to keep both sides of the relation in
                    sync, since keys are stored on both sides. Due to this they
                    are slower and should be used with caution.
                  </p>
                </td>
              </tr>
            </table>
          </div>
          <table class='table table-bordered table-striped'>
            <thead>
              <tr>
                <th>Operation</th>
                <th>Mongoid</th>
                <th>Moped</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class='doc'>
                  <code>Model#{name}</code>
                  <p class='doc'>
                    <i>Get the related documents.</i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}=</code>
                  <p class='doc'>
                    <i>
                      Set the related documents. If the parent document is persisted,
                      then the child will be saved immediately along with the parent to
                      keep the keys consistent. If setting to <code>nil</code> or
                      <code>[]</code> then the children will be deleted.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags = [ <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>) ]&#x000A;&#x000A;band.tags = <span class="predefined-constant">nil</span>&#x000A;band.tags = []</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].find(...).remove&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pull</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.<<</code><br/>
                  <code>Model#{name}.push</code>
                  <p class='doc'>
                    <i>
                      Push a new document onto the relation. If the parent is
                      persisted, then the child documents will be automatically
                      saved.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags &lt;&lt; <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.push(<span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>))</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.concat</code>
                  <p class='doc'>
                    <i>
                      Push multiple documents onto the relation. If the parent is
                      persisted, then the child documents will be automatically
                      saved in a single batch. <b>This is a batch operation that
                      runs validations, but no other callbacks.</b>
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.concat(&#x000A;  <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">new wave</span><span class="delimiter">&quot;</span></span>)&#x000A;)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert([&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... },&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">new wave</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;])&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pushAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.build</code><br/>
                  <code>Model#{name}.new</code>
                  <p class='doc'>
                    <i>
                      Build a new document in the relation with the provided
                      attributes. Does not save the new document.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td></td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.create</code><br/>
                  <code>Model#{name}.create!</code>
                  <p class='doc'>
                    <i>
                      Create a new document in the relation with the provided
                      attributes and saves. With the bang version an error will
                      be raised if validation fails.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.create(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.create!(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.clear</code><br/>
                  <code>Model#{name}.delete_all</code>
                  <p class='doc'>
                    <i>
                      Deletes all documents from the relation, without
                      running any callbacks.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.clear&#x000A;band.tags.delete_all&#x000A;band.tags.delete_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).delete_all</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.destroy_all</code>
                  <p class='doc'>
                    <i>
                      Deletes all documents from the relation, while
                      running the destroy callbacks.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.destroy_all&#x000A;band.tags.destroy_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).destroy_all</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.delete</code>
                  <p class='doc'>
                    <i>
                      Deletes the matching document from the relation.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.delete(tag)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).remove&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pull</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find</code>
                  <p class='doc'>
                    <i>
                      Return documents in the relation with matching ids. Will
                      raise an error if all the ids are not found by default.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.find(id)&#x000A;&#x000A;band.tags.find(id_one, id_two)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, { <span class="string"><span class="delimiter">&quot;</span><span class="content">$and</span><span class="delimiter">&quot;</span></span> =&gt; [{ _id: id }] }&#x000A;})&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... },&#x000A;  { <span class="string"><span class="delimiter">&quot;</span><span class="content">$and</span><span class="delimiter">&quot;</span></span> =&gt; [{ _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; [ id_one, id_two ]}}] }&#x000A;})</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find_or_create_by</code>
                  <p class='doc'>
                    <i>
                      Search for the document in the relation, and if not found
                      create a newly persisted one.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.&#x000A;  find_or_create_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>&#x000A;})&#x000A;collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.find_or_initialize_by</code>
                  <p class='doc'>
                    <i>
                      Search for the document in the relation, and if not found
                      add a new one.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.&#x000A;  find_or_initialize_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.where</code>
                  <p class='doc'>
                    <i>
                      Find matching documents in the relation. This can be any
                      criteria method, not just where.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class='doc'>
                  <code>Model#{name}.exists?</code>
                  <p class='doc'>
                    <i>
                      Returns whether or not the relation has any documents.
                    </i>
                  </p>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>band.tags.exists?</pre></div>
                  </div>
                </td>
                <td>
                  <div class="CodeRay">
                    <div class="code"><pre>collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }).count</pre></div>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </div>
    </div>
  </body>
</html>
